# Header Manipulation
## 漏洞代码

```java
/*攻击者可以发送恶意数据控制返回头，导致以下问题：
    1. cookie劫持
    2. HTTP响应分割
    3. 缓存投毒
    4. 跨站脚本攻击
*/
String name_param = request.getParameter("NAME_PARAM");
response.addHeader("param", name_param);
```
## 修复代码

```java
String name_param = request.getParameter("NAME_PARAM");
Pattern pattern = Pattern.compile("\\w");
Matcher matcher = pattern.matcher(name_param);
//输入验证，上述代码限制只能输入数字字母,也可以根据应用场景进行输入验证
if (!matcher.matches()) throw new SecurityException("Unsafe parameter");
response.addHeader("param", name_param);
```
# Header Manipulation:Cookie
## 漏洞代码
```java
/*攻击者可以发送恶意数据控制返回头，导致以下问题：
    1. cookie劫持
    2. HTTP响应分割
    3. 缓存投毒
    4. 跨站脚本攻击
*/
 @RequestMapping(value = "/headerManipulationCookie", method = RequestMethod.GET)
    public void headerManipulationCookie(HttpServletRequest request, HttpServletResponse response) {
        String name_param = request.getParameter("NAME_PARAM");
        Cookie cookie = new Cookie("name", name_param);
        cookie.setHttpOnly(true);
        response.addCookie(cookie);

    }
```
## 修复代码

```java
 @RequestMapping(value = "/headerManipulationCookie", method = RequestMethod.GET)
    public void headerManipulationCookie(HttpServletRequest request, HttpServletResponse response) {
        String name_param = request.getParameter("NAME_PARAM");

        Pattern pattern = Pattern.compile("\\w");
        Matcher matcher = pattern.matcher(name_param);
        //输入验证，上述代码限制只能输入数字字母,也可以根据应用场景进行输入验证
        if (!matcher.matches()) throw new SecurityException("Unsafe parameter");

        Cookie cookie = new Cookie("name", name_param);
        cookie.setHttpOnly(true);
        response.addCookie(cookie);

    }
```
# Path Manipulation
## 漏洞代码

```java
 @RequestMapping(value = "/pathManipulation", method = RequestMethod.GET)
    public void pathManipulation(HttpServletRequest request, HttpServletResponse response) {
        String fileName = request.getParameter("path");
        String path = VulnController.class.getClassLoader().getResource("/").getPath() + File.separator + fileName;
        File f = new File(path);
        boolean isSuccess = f.delete();
        if (isSuccess) {
            //.....
        }
        //删除选择的文件
        if (file.exists()) {
            file.delete();
        }
    }
```
## 修复代码

```java
 @RequestMapping(value = "/pathManipulation", method = RequestMethod.GET)
    public void pathManipulation(HttpServletRequest request, HttpServletResponse response) {
        //文件的id
        String id = request.getParameter("id");
        //通过文件id到数据库查询删除的文件路径
        String fileName = selectById(id);
        File f = new File(fileName);
        boolean isSuccess = f.delete();
        if (isSuccess) {
            //.....
        }
        //删除选择的文件
        if (file.exists()) {
            file.delete();
        }
    }
```
# SSRF
## 漏洞代码

```java
/*
攻击构造一个恶意的url参数,使服务端进行恶意访问,造成以下危害:
* 可以对外网服务器所在的内网、本地进行端口扫描，获取一些服务的banner信息 。
* 攻击运行在内网或者本地的应用程序。
* 对内网web应用进行指纹识别，通过访问默认文件实现 。
* 攻击内外网的web应用。sql注入、struct2、redis等。
* 利用file协议读取本地文件等。
*/
@RequestMapping(value = "/ssrf", method = RequestMethod.GET)
    public String SSRF(HttpServletRequest request, HttpServletResponse response) {
        RestTemplate restTemplate = new RestTemplate();
        String url = request.getParameter("url");

        //使用UriComponents进行url请求
        UriComponents uriComponents = UriComponentsBuilder.fromUriString(url).build();
        URI uri = uriComponents.toUri();
        ResponseEntity<String> responseEntity = restTemplate.getForEntity(uri, String.class);
        return responseEntity.getBody();

    }
```
## 修复代码

```java
@RequestMapping(value = "/ssrf", method = RequestMethod.GET)
    public String SSRF(HttpServletRequest request, HttpServletResponse response) {
        RestTemplate restTemplate = new RestTemplate();
        String url = request.getParameter("url");
        //对URL进行安全检测
        if (!SecurityUtil.checkURL(url)) {
            throw new SecurityException("Unsafe url");
        }

        UriComponents uriComponents = UriComponentsBuilder.fromUriString(url).build();
        URI uri = uriComponents.toUri();
        ResponseEntity<String> responseEntity = restTemplate.getForEntity(uri, String.class);
        return responseEntity.getBody();

    }
    
class SecurityUtil {
    public static boolean isHttp(String url) {
        return url.startsWith("http://") || url.startsWith("https://");
    }

    public static String gethost(String url) {
        try {
            URI uri = new URI(url);
            return uri.getHost().toLowerCase();
        } catch (URISyntaxException e) {
            return "";
        }
    }

    public static boolean checkURL(String url) {
        if (null == url) {
            return false;
        }
        //URL白名单
        ArrayList<String> safeDomains = getSafeDomains();
        //URL黑名单
        ArrayList<String> blockDomains = getBlockDomains();

        try {
            String host = gethost(url);

            // 必须http/https
            if (!isHttp(url)) {
                return false;
            }

            // 如果满足黑名单返回null
            if (blockDomains.contains(host)) {
                return false;
            }
            for (String blockDomain : blockDomains) {
                if (host.endsWith("." + blockDomain)) {
                    return false;
                }
            }

            // 支持多级域名
            if (safeDomains.contains(host)) {
                return true;
            }

            // 支持一级域名
            for (String safedomain : safeDomains) {
                if (host.endsWith("." + safedomain)) {
                    return true;
                }
            }
            return false;
        } catch (NullPointerException e) {
//            logger.error(e.toString());
            return false;
        }
    }

    /*
    域名黑名单
     */
    private static ArrayList<String> getBlockDomains() {
        return new ArrayList<String>();
    }

    /*
        安全的域名
    */
    private static ArrayList<String> getSafeDomains() {
        return new ArrayList<String>();
    }
```
# Unreleased Resource:stream
## 漏洞代码

```java
/*
如果攻击者能够故意触发资源泄漏，该攻击者就有可能通过耗尽资源池的方式发起 denial of servic.
*/
 @RequestMapping(value = "/unreleasedResource", method = RequestMethod.GET)
    public void unreleasedResource(HttpServletRequest request, HttpServletResponse response) {
        FileInputStream inputStream = null;
        String fName = "./application.properties";
        try {
            inputStream = new FileInputStream(fName);
            byte[] bytes = new byte[1024];
            int sz;
            StringBuilder builder = new StringBuilder();

            while ((sz = inputStream.read(bytes)) != -1) {
                builder.append(Arrays.toString(bytes));
            }
            response.getWriter().write(builder.toString());
        } catch (Exception e) {

        } 
    }
```
## 修复代码

```java
@RequestMapping(value = "/unreleasedResource", method = RequestMethod.GET)
    public void unreleasedResource(HttpServletRequest request, HttpServletResponse response) {
        FileInputStream inputStream = null;
        String fName = "./application.properties";
        try {
            inputStream = new FileInputStream(fName);
            byte[] bytes = new byte[1024];
            int sz;
            StringBuilder builder = new StringBuilder();

            while ((sz = inputStream.read(bytes)) != -1) {
                builder.append(Arrays.toString(bytes));
            }
            response.getWriter().write(builder.toString());
        } catch (Exception e) {

        } finally {
            //在finally中正确关闭输入流
            safeClose(inputStream);
        }
    }
    
public void safeClose(InputStream is) {
        if (is != null) {
            try {
                is.close();
            } catch (IOException e) {
                //
            }
        }
    }
```
# 越权
## 漏洞代码

```java
/*
攻击者通过遍历infoId,获取任意信息
*/
@RequestMapping(value = "/accessControl", method = RequestMethod.GET)
    public void accessControl(HttpServletRequest request, HttpServletResponse response) {
        String accountId = request.getParameter("infoId");
        HashMap<String, String> hashMap = new HashMap<>();
        hashMap.put("infoId", accountId);
        InfoDao infoDao = new InfoDao();
        boolean isSuccess = infoDao.selectInfoById(hashMap);
        if (isSuccess) {
            //....
        }
    }
```
## 修复代码

```java
@RequestMapping(value = "/accessControl", method = RequestMethod.GET)
    public void accessControl(HttpServletRequest request, HttpServletResponse response) {
         String accountId = request.getParameter("infoId");
        HashMap<String, String> hashMap = new HashMap<>();
        hashMap.put("infoId", accountId);
        InfoDao infoDao = new InfoDao();
        boolean isSuccess = infoDao.selectInfoById(hashMap);
        String userId = (String) request.getSession().getAttribute("userId");
        hashMap.put("userId", userId);
        //id应设置成不可遍历,如使用uuid作为唯一标识
        //通过userid和accountId查询
        boolean isSuccess = infoDao.selectInfoByIdAndUserId(hashMap);
        if (isSuccess) {
            //....
        }
    }
```
# Portability Flaw: Locale Dependent Comparison
## 漏洞代码
对可能与区域设置相关的数据进行比较时，应指定相应的区域设置。
```java
/*
在使用不带区域设置的java.lang.String.toUpperCase() 时，其将使用默认的区域设置规则。使用土耳其区域设置"title".toUpperCase() 时将返回 "T\u0130TLE"，其中 "\u0130" 是 "LATIN CAPITAL LETTER I WITH DOT ABOVE" 字符。这会导致生成意外结果，在以下示例中会导致此验证无法捕获 "sciprt" 一词，从而可能造成跨站脚本攻击漏洞。
*/
String str = request.getParameter("str");
        //设置地区
        if (str.toUpperCase(Locale.CHINA).equals("SCIRPT")) {
            throw new SecurityException("xss");
        } else {
            //...
        }
```
## 修复代码

```java
String str = request.getParameter("str");
        //设置地区
        if (str.toUpperCase(Locale.CHINA).equals("TITLE")) {
            //...
        } else {
            //...
        }
```
# Access Specifier Manipulation
## 漏洞代码

```java
/*
允许程序员绕过由 Java 访问说明符提供的 access control 检查。特别是它让程序员能够允许反映对象绕过 Java access control，并反过来更改私有字段或调用私有方法、行为
*/
public static Object mapToObject(Map<String, String> map, Class<?> beanClass) throws IllegalAccessException, InstantiationException {
        if (map == null) {
            return null;
        }
        Object obj = beanClass.newInstance();
        Field[] fields = obj.getClass().getDeclaredFields();
        for (Field field : fields) {
            int mod = field.getModifiers();
            if (Modifier.isStatic(mod) || Modifier.isFinal(mod)) {
                continue;
            }
            //访问私有变量
            field.setAccessible(true);
            field.set(obj, map.get(field.getName()));
        }
        return obj;
    }
```
## 修复代码

```java
/*
该方法仔细检查被使用的场景,只能使用在攻击者无法设置的参数中.
*/
```
# Insecure Randomness
## 漏洞代码

```java
/*
应用使用弱随机数作为session的key,该session将
*/
@RequestMapping(value = "/random", method = RequestMethod.GET)
    public void random(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        HttpSession session = request.getSession();
        String name = request.getParameter("name");
        //Random.nextInt() 是一个统计学的 PRNG，攻击者很容易猜到由它所生成的字符串。
        Random random = new Random();
        session.setAttribute("userId", name + random.nextInt(4000000));
    }
```
## 修复代码

```java
@RequestMapping(value = "/random", method = RequestMethod.GET)
    public void random(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        HttpSession session = request.getSession();
        String name = request.getParameter("name");
        //使用secureRandom生成一个不可预测的随机数
        SecureRandom secureRandom = SecureRandom.getInstance("SHA-1");
        int nextInt = secureRandom.nextInt();
        session.setAttribute("userId", name + nextInt);
    }
```
# HTTP Header劫持
## 漏洞代码
```java
/*  Servlet 只有一个实例，并通过使用和重复使用该单个实例来处理需要由不同线程同时处理的多个请求。 这种误解的共同后果是，开发者使用Servlet 成员字段的这种方式会导致某个用户可能在无意中看到其他用户的数据。
*/
public String name;
    @RequestMapping(value = "/raceCondition", method = RequestMethod.GET)
    public void singleton(HttpServletRequest request, HttpServletResponse response) {
        this.name = request.getParameter("name");
        response.getWriter().write(this.name);
    }
```
## 修复代码

```java
    @RequestMapping(value = "/raceCondition", method = RequestMethod.GET)
    public void singleton(HttpServletRequest request, HttpServletResponse response) {
    //将name作为局部变量
         String name =  = request.getParameter("name");
        response.getWriter().write(this.name);
    }
```
# Weak Encryption: Insecure Mode of Operation
## 漏洞代码

```java
/*
下面的代码采用RSA加密没有使用padding scheme
*/
public static String encrypt(String source, RSAPublicKey publicKey) {
        try {
            Cipher cipher = Cipher.getInstance("RSA/None/NoPadding");
            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
            byte[] bytes = cipher.doFinal(source.getBytes());
            return Arrays.toString(bytes);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException e) {

        } catch (BadPaddingException | IllegalBlockSizeException e) {
            e.printStackTrace();
        }
        //...
    }
```
## 修复代码

```java
public static String encrypt(String source, RSAPublicKey publicKey) {
        try {
        //为了使用RSA更安全,必须采用OAEP
            Cipher cipher = Cipher.getInstance("RSA/ECB/OAEPWithMD5AndMGF1Padding");
            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
            byte[] bytes = cipher.doFinal(source.getBytes());
            return Arrays.toString(bytes);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException e) {

        } catch (BadPaddingException | IllegalBlockSizeException e) {
            e.printStackTrace();
        }
        return null;
    }
```
# cross site script:reflect
## 漏洞代码

```java
/*
攻击者输入<script>alert(document.cookie)</script>等攻击代码获取用户cookie或者劫持用户浏览器.
*/
@RequestMapping(value = "/xss", method = RequestMethod.GET)
    public String xss(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        ResultInfo resultInfo = new ResultInfo();
        HashMap<String, Object> table = new HashMap<>();
        table.put("data", "data");
        resultInfo.setBody(table);
        Object json = JSON.toJSON(resultInfo);
        String callback = request.getParameter("callback");
        return callback + "(" + json.toString() + ")";
    }
```
## 修复代码

```java
//将返回包的类型设置为application/json
 @RequestMapping(value = "/xss", method = RequestMethod.GET,produces = "application/json")
    public String xss(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        ResultInfo resultInfo = new ResultInfo();
        HashMap<String, Object> table = new HashMap<>();
        table.put("data", "data");
        resultInfo.setBody(table);
        Object json = JSON.toJSON(resultInfo);
        //采用ESAPI对返回值进行编码.(https://github.com/ESAPI/esapi-java-legacy/tree/esapi-2.2.1.1)
        String callback = ESAPI.encoder().encodeForHTML(request.getParameter("callback"));

        return callback + "(" + json.toString() + ")";
    }
```
# System Information leak
## 漏洞代码

```java
@RequestMapping(value = "/sysinfoleak", method = RequestMethod.GET)
    public String sysInfoLeak(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        ResultInfo resultInfo = new ResultInfo();
        try {
            HashMap<String, Object> table = new HashMap<>();
            table.put("data", Integer.parseInt(request.getParameter("id")));
            resultInfo.setBody(table);
            Object json = JSON.toJSON(resultInfo);
            return json.toString();
        } catch (Exception e) {
            //若系统产生异常,将会打印系统异常信息,泄漏出调用栈等信息
            resultInfo.setMessage(e.getMessage());
            return JSON.toJSON(resultInfo).toString();
        }

    }
```
## 修复代码

```java
@RequestMapping(value = "/sysinfoleak", method = RequestMethod.GET)
    public String sysInfoLeak(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        ResultInfo resultInfo = new ResultInfo();
        try {
            HashMap<String, Object> table = new HashMap<>();
            table.put("data", Integer.parseInt(request.getParameter("id")));
            resultInfo.setBody(table);
            Object json = JSON.toJSON(resultInfo);
            return json.toString();
        } catch (Exception e) {
            //将异常信息打印到日志中
            logger.error(e.getMessage())
        }

    }
```
# Poor Error Handling: Return Inside Finally
## 漏洞代码

```java
/*
finally块内部返回，这将导致异常丢失
 */
    @RequestMapping(value = "/poorerrorHandler", method = RequestMethod.GET)
    public String poorErrorHandler(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        ResultInfo resultInfo = new ResultInfo();
        try {
            HashMap<String, Object> table = new HashMap<>();
            table.put("data", Integer.parseInt(request.getParameter("id")));
            resultInfo.setBody(table);
            Object json = JSON.toJSON(resultInfo);
            return json.toString();
        } catch (Exception e) {
            resultInfo.setMessage(e.getMessage());
            Logger.getLogger("poor").error(JSON.toJSON(resultInfo).toString());
        } 
        finally {
            //直接在finally return
            return "";
        }

    }
```
## 修复代码

```java
/*
finally块中的return语句将导致丢弃try块中可能引发的任何异常
*/
@RequestMapping(value = "/poorerrorHandler", method = RequestMethod.GET)
    public String poorErrorHandler(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        ResultInfo resultInfo = new ResultInfo();
        try {
            HashMap<String, Object> table = new HashMap<>();
            table.put("data", Integer.parseInt(request.getParameter("id")));
            resultInfo.setBody(table);
            Object json = JSON.toJSON(resultInfo);
            return json.toString();
        } catch (Exception e) {
            resultInfo.setMessage(e.getMessage());
            Logger.getLogger("poor").error(JSON.toJSON(resultInfo).toString());
        } 
        //将return语句移到finally块之外。如果必须返回finally块内部的值，只需
将其赋给一个局部变量，并在finally块执行后返回该值
    return "";

    }
```
# Code Correctness: Double-Checked Locking
## 漏洞代码

```java

private static byte[] lock = new byte[0];

    public static void getExecutorService(String executorService) {
    /*
    程序本意是保证只有一个executorService,但在某些情况.多个executorService对象将会产生
    */
        if (null == executorService) {
            synchronized (lock) {
                if (null == executorService) {
                    //do something
                }
            }
        }
    }
```
## 修复代码

```java
private static byte[] lock = new byte[0];
public static void getExecutorService(String executorService) {
//使用最直接的方法进行判断
        synchronized (lock) {
            if (null == executorService) {
                    //do something
            }
        }
}
```

# j2ee bad practices:Non-Serializable
## 漏洞代码

```java
@RequestMapping(value = "/j2eebad", method = RequestMethod.GET)
    public void j2eebadp(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        try {
            //... do something
            request.getSession().setAttribute("assistantAssignSuccess", "W");
        } catch (Exception e) {
            //直接将非序列化对象设置到session中
            request.setAttribute("assistantAssignSuccess", new ResultInfo());
            //...
        }
    }

```
## 修复代码

```java
@RequestMapping(value = "/j2eebad", method = RequestMethod.GET)
    public void j2eebadp(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        try {
            //... do something
            request.getSession().setAttribute("assistantAssignSuccess", "W");
        } catch (Exception e) {
            //将ResultInfo实现java.io.serializable接口
            request.setAttribute("assistantAssignSuccess", new ResultInfo());
            //...
        }
    }
```
# unsafe deserialization
## 漏洞代码

```java
@RequestMapping(value = "/ud", method = RequestMethod.GET)
    public void ud(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        ServletInputStream inputStream = request.getInputStream();
        //攻击者传输恶意攻击代码执行反序列化导致命令执行
        List<AccountDao> accountDaos = deserialzeObj(inputStream);
        //...
    }
public static List<AccountDao> deserialzeObj(InputStream in) throws IOException {
        List<AccountDao> accountDaos = new ArrayList<AccountDao>();
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(in);
            while (true) {
                AccountDao accountDao = (AccountDao) ois.readObject();
                if (accountDao != null) {
                    accountDaos.add(accountDao);
                } else {
                    break;
                }
            }

        } catch (Exception e) {

        } finally {
            if (ois != null) ois.close();
        }
        return accountDaos;
    }
```
## 修复代码

```java
@RequestMapping(value = "/ud", method = RequestMethod.GET)
    public void ud(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
     //攻击者传输恶意序列化对象,当执行反序列化操作时,执行序列化对象的代码,导致命令执行
        ServletInputStream inputStream = request.getInputStream();
        List<AccountDao> accountDaos = deserialzeObj(inputStream);
        //...
    }
public static List<AccountDao> deserialzeObj(InputStream in) throws IOException {
        List<AccountDao> accountDaos = new ArrayList<AccountDao>();
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(in);
            while (true) {
                //反序列对象操作
                AccountDao accountDao = (AccountDao) ois.readObject();
                if (accountDao != null) {
                    accountDaos.add(accountDao);
                } else {
                    break;
                }
            }

        } catch (Exception e) {

        } finally {
            if (ois != null) ois.close();
        }
        return accountDaos;
    }
//使用一个类继承ObjectInputStream,修改resolveClass方法,以下分别以白名单和黑名单的判断反序列化的对象.
public class SafeObjectInputStream extends ObjectInputStream {
    //白名单限制反序列化对象
    public String[] white_list = new String[]{AccountDao.class.getName()};
    //黑名单限制，需要实时维护黑名单
    public String[] black_list = new String[]{
            "org.apache.commons.collections4.comparators",
            "org.python.core",
            "org.apache.tomcat",
            "org.apache.xalan",
            "javax.xml",
            "org.springframework.",
            "org.apache.commons.beanutils",
            "org.apache.commons.collections.Transformer",
            "org.apache.commons.collections.Transformer",
            "org.codehaus.groovy.runtime",
            "java.lang.Thread",
            "javax.net.",
            "com.mchange",
            "org.apache.wicket.util",
            "java.util.jar.",
            "org.mozilla.javascript",
            "java.rmi",
            "java.util.prefs.",
            "com.sun.",
            "java.util.logging.",
            "org.apache.bcel",
            "java.net.Socket",
            "org.apache.commons.fileupload",
            "org.jboss",
            "org.hibernate",
            "org.apache.commons.collections.functors",
            "org.apache.myfaces.context.servlet",
            "java.net.URL",
            "junit.",
            "org.apache.ibatis.datasource",
            "org.osjava.sj.",
            "org.apache.log4j.",
            "org.logicalcobwebs.",
            "org.apache.logging.",
            "org.apache.commons.dbcp",
            "com.ibatis.sqlmap.engine.datasource",
            "org.jdom.",
            "	org.slf4j. ",
            "javassist.",
            "oracle.net",
            "org.jaxen.",
            "java.net.InetAddress",
            "java.lang.Class",
            "com.alibaba.fastjson.annotation",
            "org.apache.cxf.jaxrs.provider.",
            "ch.qos.logback.",
            "net.sf.ehcache.transaction.manager.",
            "com.zaxxer.hikari.",
            "flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor",
            "org.apache.openjpa.ee.",
            "oracle.jdbc.rowset.OracleJDBCRowSet",
            "com.mysql.cj.jdbc.admin.",
            "	oracle.jdbc.connector.OracleManagedConnectionFactory",
            "org.apache.ibatis.parsing.",
            "org.apache.axis2.jaxws.spi.handler.",
            "jodd.db.connection.",
            "org.apache.commons.configuration.JNDIConfiguration",
            "org.apache.ibatis.executor.",
            "net.sf.cglib.",
            "oracle.net.",
            "com.mysql.cj.jdbc.MysqlDataSource",
            "jdk.internal.",
            "aj.org.objectweb.asm.",
            "oracle.jdbc.",
            "org.apache.commons.collections.comparators.",
            "net.sf.ehcache.hibernate.",
            "com.mysql.cj.log.",
            "org.h2.jdbcx.",
            "org.apache.commons.logging.",
            "org.apache.ibatis.reflection.",
            "org.h2.server.",
            "org.apache.ibatis.datasource.",
            "org.objectweb.asm.",
            "flex.messaging.util.concurrent.",
            "org.apache.ibatis.javassist.",
            "java.lang.UNIXProcess",
            "org.apache.ibatis.ognl.",
            "com.mysql.cj.jdbc.MysqlConnectionPoolDataSource",
            "org.codehaus.jackson.",
            "org.apache.ibatis.scripting.",
            "org.apache.commons.proxy.",
            "com.mysql.cj.jdbc.MysqlXADataSource",
            "org.apache.commons.collections.functors.",
            "org.apache.commons.configuration",
            "javax.script.",
            "javax.sound.",
            "javax.print.",
            "javax.activation.",
            "javax.tools.",
            "javax.management.",
            "org.apache.xbean.",
            "org.eclipse.jetty.",
            "javax.naming.",
            "org.apache.shiro.realm.",
            "org.apache.http.conn.",
            "org.quartz.",
            "com.taobao.eagleeye.wrapper",
            "org.apache.http.impl.",
            "com.ibatis.",
            "org.apache.catalina.",
            "org.apache.http.auth.",
            "br.com.anteros.",
            "com.caucho.",
            "org.apache.http.cookie.",
            "org.javasimon.",
            "org.apache.cocoon.",
            "org.apache.activemq.jms.pool.",
            "org.mortbay.jetty.",
            "org.apache.shiro.jndi.",
            "org.apache.http.cookie.",
            "org.javasimon.",
            "org.apache.cocoon. ",
            "org.apache.activemq.jms.pool.",
            "org.mortbay.jetty.",
            "org.apache.shiro.jndi.",
            "org.apache.ignite.cache.jta.",
            "javax.swing.J",
            "org.aoju.bus.proxy.provider.",
            "java.awt.p",
            "java.awt.i",
            "java.io.Serializable",
            "java.io.Closeable",
            "oracle.jms.AQ",
            "java.util.Collection",
            "java.lang.Iterable",
            "java.lang.Object",
            "java.lang.AutoCloseable",
            "java.lang.Readable",
            "java.lang.Cloneable",
            "java.lang.Runnable",
            "java.util.EventListener",
            "org.apache.commons.collections4.Transformer",
            "org.apache.commons.collections4.functors",
            "org.jdom2.transform.",
            "org.apache.hadoop.shaded.com.zaxxer.hikari.",
            "com.p6spy.engine.",
            "org.apache.activemq.pool.",
            "org.apache.aries.transaction.",
            "org.apache.activemq.ActiveMQConnectionFactory",
            "org.apache.activemq.spring. ",
            "org.apache.activemq.ActiveMQXAConnectionFactory",
            "org.apache.commons.jelly.",
            "org.apache.axis2.transport.jms.",};

    public SafeObjectInputStream(InputStream in) throws IOException {
        super(in);
    }

    @Override
    protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
        String name = desc.getName();
        Boolean isResolve = false;
        //for(String black_name : black_list)
        //如果类名不在白名单中,抛出异常
        for (String white_name : white_list) {
            if (white_name.equalsIgnoreCase(name)) {
                isResolve = true;
            }
        }
        if (!isResolve) throw new SecurityException("unsafe object");
        return super.resolveClass(desc);
    }
}
```
# File Disclosure：Spring
## 漏洞代码

```java
 @RequestMapping(value = "/fd", method = RequestMethod.GET)
    public ModelAndView fileDisclosure(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        /*
        如果攻击者使用请求参数提供与某个敏感文件位置相匹配的URL，他们将能够查看该文件。 例如，使用"http://www.yourcorp.com/webApp/logic?view=WEB-INF/applicationContext.xml" 将能够查看该应用程序的 applicationContext.xml 文件。 一旦攻击者掌握了 applicationContext.xml 的信息，他们便能够定位和下载 applicationContext.xml 中引用的其他配置文件，甚至类文件或 jar 文件。 这样一来，攻击者将能够获得与应用程序有关的敏感信息，并以之为目标发动其他类型的攻击。
         */
        
        String view = request.getParameter("view");
        HashMap<String, Object> hashMap = new HashMap<>();
        hashMap.put("viewId", view);
        return new ModelAndView(view);
    }

```
## 修复代码

```java
/*
        服务器端逻辑应具有逻辑名称与服务器端路径的映射（以逻辑名称为键）,比如设置设置访问的路径为view=login.
*/
```
# insecure Transport:mail transmission
## 漏洞代码

```java
public void sendMail() throws UnsupportedEncodingException, MessagingException {
        Properties properties = new Properties();
        properties.setProperty("mail.transport", "smtp");
        properties.setProperty("mail.smtp.host", "localhost");
        properties.setProperty("mail.smtp.auth", "true");
        Session session = Session.getDefaultInstance(properties);
        MimeMessage message = new MimeMessage(session);
        message.setFrom(new InternetAddress("", "", "utf-8"));
    }

```
## 修复代码

```java
```
# Weak Encryption:Insufficient key size
## 漏洞代码

```java
public static KeyPair initKey() throws NoSuchAlgorithmException {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("SHA256withRSA");
        //当密钥长度太短,加密算法可能会被破解
        int KEY_SIZE = 512;
        keyPairGenerator.initialize(KEY_SIZE);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        return keyPair;
    }

```
## 修复代码

```java
public static KeyPair initKey() throws NoSuchAlgorithmException {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("SHA256withRSA");
        //使用RSA算法时，确保key的长度至少为2048
        int KEY_SIZE = 2048;
        keyPairGenerator.initialize(KEY_SIZE);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        return keyPair;
    }
```
# formula injection
## 漏洞代码

```java
 @RequestMapping(value = "/csvinjection", method = RequestMethod.GET)
    public void fi(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        //攻击者输入文件内容=1+cmd|' /C calc'!A0,当受害者触发命令
        String fileName = "test.csv";
        response.setContentType("multipart/form-data");
        response.setHeader("Content-Disposition", "attachment;fileName=" + fileName);
        response.addHeader("Content-Type", "text/csv");
        ServletOutputStream out = null;
        try {
            out = response.getOutputStream();
            //输出csv文件的内容可控
            String content = request.getParameter("content");
            for (String fc : filter_char) {
                if (content.startsWith(fc)) {
                    throw new SecurityException("unsafe char");
                }
            }
            out.write(content.getBytes());
        } catch (IOException e) {
            //print log
        } finally {
            if (out != null) out.close();
        }

    }

```
## 修复代码

```java
 @RequestMapping(value = "/csvinjection", method = RequestMethod.GET)
    public void fi(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException {
        //攻击者输入文件内容=1+cmd|' /C calc'!A0触发命令
        String fileName = "test.csv";
        response.setContentType("multipart/form-data");
        response.setHeader("Content-Disposition", "attachment;fileName=" + fileName);
        response.addHeader("Content-Type", "text/csv");
        ServletOutputStream out = null;
        try {
            out = response.getOutputStream();
            //输出csv文件的内容可控，可能通过sql获取内容
            String content = request.getParameter("content");
            //对内容进行判断，过滤 = + - @
            String[] filter_char = new String[]{"=", "+", "-", "@"};
            for (String fc : filter_char) {
                if (content.startsWith(fc)) {
                   content =  content.replace(fc,"");
                }
            }
            out.write(content.getBytes());
        } catch (IOException e) {
            //print log
        } finally {
            if (out != null) out.close();
        }
    }
```
# HTTP parameter pollution
## 漏洞代码

```java
@RequestMapping(value = "/hpp", method = RequestMethod.GET)
    public ResultInfo hpp(@PathVariable String env, @RequestParam String namespaceName) {
        return getByNamespace(namespaceName);

    }

    private ResultInfo getByNamespace(String namespaceName) {
        RestTemplate restTemplate = new RestTemplate();
        //用户输入namespaceName=1&instanceId=22即可改变instanceId参数的值
        namespaceName = namespaceName.replaceAll("&", "");
        ResponseEntity<ResultInfo> entity = restTemplate.getForEntity("/instances/by-namespace?appId=xxxx&namespaceName=" + namespaceName + "&instanceId=xxxxx", ResultInfo.class);
        return entity.getBody();
    }

```
## 修复代码

```java
@RequestMapping(value = "/hpp", method = RequestMethod.GET)
    public ResultInfo hpp(@PathVariable String env, @RequestParam String namespaceName) {
        return getByNamespace(namespaceName);

    }

    private ResultInfo getByNamespace(String namespaceName) {
        RestTemplate restTemplate = new RestTemplate();
        //过滤&
        namespaceName = namespaceName.replaceAll("&", "");
        ResponseEntity<ResultInfo> entity = restTemplate.getForEntity("/instances/by-namespace?appId=xxxx&namespaceName=" + namespaceName + "&instanceId=xxxxx", ResultInfo.class);
        return entity.getBody();
    }
```
#  Unreleased Resource: Database
## 漏洞代码

```java
/*
以下代码会执行数据库查询指令，处理数据库返回的结果，并关闭已分配的指令对象。 但如果在执行 SQL 或是处理结果时发生异常，指令对象将不会关闭。 如果这种情况频繁出现，数据库将用完所有可用的指针，且不能再执行任何 SQL 查询.
*/
@RequestMapping(value = "/urd", method = RequestMethod.GET)
    public void urd() throws SQLException {
        Connection connection = null;
        try {
            connection = getDS();
            PreparedStatement statement = connection.prepareStatement("select * from userinfo where UserName=?");
            //...
            statement.close();
        } catch (Exception e) {
            //
        } finally {
            if (connection != null) connection.close();
        }
    }

    public Connection getDS() throws SQLException {
        //以下仅为了测试代码易查看，实际禁止直接硬编码，
        String URL = "jdbc:mysql://127.0.0.1:3306/Supermarket?characterEncoding=utf-8";
        String USER = "root";
        String PASSWORD = "123";
        return DriverManager.getConnection(URL, USER, PASSWORD);
    }

```
## 修复代码

```java
@RequestMapping(value = "/urd", method = RequestMethod.GET)
    public void urd() throws SQLException {
        Connection connection = null;
        PreparedStatement statement = null;
        try {
            connection = getDS();
            statement = connection.prepareStatement("select * from userinfo where UserName=?");
            //...
            
        } catch (Exception e) {
            //
        } finally {
            if (statement != null) statement.close();
            if (connection != null) connection.close();
        }
    }

    public Connection getDS() throws SQLException {
        //以下仅为了测试代码易查看，实际禁止直接硬编码，
        String URL = "jdbc:mysql://127.0.0.1:3306/Supermarket?characterEncoding=utf-8";
        String USER = "root";
        String PASSWORD = "123";
        return DriverManager.getConnection(URL, USER, PASSWORD);
    }
```
# Insecure SSl: server Identity Verification Disabled
## 漏洞代码
/*
在某些api中,使用SSL连接时,默认不会验证证书,相当于信任所有证书.
*/
```java
private String from;
    private String subject;
    private String htmlMsg;

    public String runByApacheMail() throws EmailException {
    //当攻击伪造一个恶意证书时,应用将会泄漏敏感信息.
        HtmlEmail email = new HtmlEmail();
        email.setCharset(EmailConstants.UTF_8);
        String hostName = "smtp.servermail.com";
        email.setHostName(hostName);
        email.setSmtpPort(465);
        email.setFrom(from);
        email.setSubject(subject);
        email.setHtmlMsg(htmlMsg);
        email.setSentDate(new Date());
        String str = email.send();
        return str;
    }

```
## 修复代码

```java
private String from;
    private String subject;
    private String htmlMsg;

    public String runByApacheMail() throws EmailException {
        HtmlEmail email = new HtmlEmail();
        email.setCharset(EmailConstants.UTF_8);
        String hostName = "smtp.servermail.com";
        email.setHostName(hostName);
        email.setSmtpPort(465);
        email.setFrom(from);
        //应用必须验证服务器证书并且使用ssl连接。
        email.setAuthenticator(new DefaultAuthenticator("", ""));
        email.setSSLCheckServerIdentity(true);
        email.setSSLOnConnect(true);

        email.setSubject(subject);
        email.setHtmlMsg(htmlMsg);
        email.setSentDate(new Date());
        String str = email.send();
        return str;
    }
```
# Weak Encryption: insecure initialization vector
## 漏洞代码

```java
/*
使用可预测的密码文本容易受到字典攻击
*/
//初始化变量使用硬编码字节创建非随机IV
    public static final byte[] IV = {(byte) 0xf9, (byte) 0xf9, (byte) 0xf9, (byte) 0xf9, (byte) 0xf9, (byte) 0xf9, (byte) 0xf9, (byte) 0xf9};

    public static String encrypt(String plainText, String key) {
        //创建完全随机的IV或者部分随机

        IvParameterSpec spec = new IvParameterSpec(IV);
        //...
        return null;
    }

```
## 修复代码

```java
public static String encrypt(String plainText, String key) {
        //采用完全随机的IV或者部分随机
        SecureRandom secureRandom = new SecureRandom();
        byte[] iv = secureRandom.generateSeed(16);

        IvParameterSpec spec = new IvParameterSpec(iv);
        //...
        return null;
    }
```
# unreleased Resource:Synchronization
## 漏洞代码

```java
/*
代码在deserialzeObj前加锁,当deserialzeObj出现异常后,跳过执行 masterLock.readLock().unlock()方法,导致该锁无法释放
*/
public static void refreshMaster() {
        ReentrantReadWriteLock masterLock = new ReentrantReadWriteLock();
        try {
            masterLock.readLock().lock();
            deserialzeObj(null);
            masterLock.readLock().unlock();
        } catch (Exception e) {
            //
        } 
    }

```
## 修复代码

```java
public static void refreshMaster() {
        ReentrantReadWriteLock masterLock = new ReentrantReadWriteLock();
        try {
            masterLock.readLock().lock();
            deserialzeObj(null);
        } catch (Exception e) {

        } finally {
        //在finally
            masterLock.readLock().unlock();
        }
    }
```
#  Dynamic Code Evaluation:JNDI Reference Injection
## 漏洞代码

```java
@RequestMapping(value = "/jndi", method = RequestMethod.GET)
    public void mockAnShuoCallTCByEJB(HttpServletRequest request) {
        String providerUrl = request.getParameter("providerUrl");
        String principal = request.getParameter("principal");
        String credentials = request.getParameter("credentials");
        String jndiName = request.getParameter("jndiName");
        //攻击者构造恶意payload（比如:输入jndiName=ldap://localhost:1389/Exploit）远程加载恶意类,执行任意代码
        try {
            Properties properties = new Properties();
            properties.put(Context.PROVIDER_URL, providerUrl);
            properties.put(Context.INITIAL_CONTEXT_FACTORY, "weblogic.jndi.WLInitialContextFactory");
            properties.put(Context.SECURITY_PRINCIPAL, principal);
            properties.put(Context.SECURITY_CREDENTIALS, credentials);
            InitialContext context = new InitialContext(properties);
            context.lookup(jndiName);
            //...
        } catch (NamingException e) {
            //...
        }
    }

```
## 修复代码

```java
@RequestMapping(value = "/jndi", method = RequestMethod.GET)
    public void mockAnShuoCallTCByEJB(HttpServletRequest request) {
        String providerUrl = request.getParameter("providerUrl");
        String principal = request.getParameter("principal");
        String credentials = request.getParameter("credentials");
        String jndiName = request.getParameter("jndiName");
        //白名单校验jndiName
        if (!"xxxx".equals(jndiName)) {
            throw new SecurityException("Incorrect jndi name");
        }
        try {
            Properties properties = new Properties();
            properties.put(Context.PROVIDER_URL, providerUrl);
            properties.put(Context.INITIAL_CONTEXT_FACTORY, "weblogic.jndi.WLInitialContextFactory");
            properties.put(Context.SECURITY_PRINCIPAL, principal);
            properties.put(Context.SECURITY_CREDENTIALS, credentials);
            InitialContext context = new InitialContext(properties);
            context.lookup(jndiName);
            //...
        } catch (NamingException e) {
            //...
        }
    }
```
# Insecure Transport
## 漏洞代码
/*
程序内部访问http请求,易被中间人监听
*/
```java
@RequestMapping(value = "/it", method = RequestMethod.GET)
    public void it(HttpServletRequest request) throws IOException {
        sendPost("http://test.com.cn", "a=1&b=1");
    }

    @Resource(name = "httpclient")
    private static CloseableHttpClient httpClient;

    public static String sendPost(String url, String postData) throws IOException {
        HttpPost httpPost = new HttpPost(url);
        StringEntity entity = new StringEntity(postData, ContentType.APPLICATION_JSON);
        httpPost.setEntity(entity);
        httpPost.setHeader(new BasicHeader("Accept", "application/json;charset=utf-8"));
        HttpHost host = new HttpHost(httpPost.getURI().getHost(), httpPost.getURI().getPort());
        HttpClientContext context = HttpClientContext.create();
        CloseableHttpResponse response = httpClient.execute(host, httpPost, context);
        //....
        return null;
    }

```
## 修复代码

```java
@RequestMapping(value = "/it", method = RequestMethod.GET)
    public void it(HttpServletRequest request) throws IOException {
        //使用https代替http
        sendPost("https://test.com.cn", "a=1&b=1");
    }
    
```
# HTML5: Missing Content Security Policy
## 漏洞代码

```java
/*
应用未设置Content Security Policy策略.
Content Security Policy 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。
*/
public void confiure(HttpSecurity httpSecurity) throws Exception {
        httpSecurity.csrf().disable();
        
    }

```
## 修复代码

```java
public void confiure(HttpSecurity httpSecurity) throws Exception {
        httpSecurity.csrf().disable();
        /*
        根据应用需求,增加csp头
        object-src – 决定从哪里加载和执行插件。
        style-src – 决定从哪里加载css和样式标记。
        img-src – 决定从哪里加载图片。
        media-src – 决定从哪里加载视频和音频资源。
        frame-src – 决定哪里的frames 可以被嵌入。
        font-src – 决定从哪里加载字体。
        connect-src – 限制在 XMLHttpRequest, WebSocket 和 EventSource 中可以使用哪些类型的资源。
        sandbox – 这是一个可选形式，它决定了沙盒的策略，如何将内容嵌入到沙盒中以保证安全。
         */
        String policy = "";
        httpSecurity.headers().contentSecurityPolicy(policy);
    }
```
# Dynamic Code Evaluation:Script Injection
## 漏洞代码

```java
/*
由于javascript引擎允许执行java代码,攻击者输入java.lang.Runtime.getRuntime().exec("id")即可执行任意命令.
*/
 @RequestMapping(value = "/si", method = RequestMethod.GET)
    public void decompress(HttpServletRequest request) throws IOException {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("javascript");
        try {
            engine.eval(request.getParameter("operation"));
        } catch (ScriptException e) {
            //
        }

    }

```
## 修复代码

```java
ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("javascript");
        try {
        //使用白名单.将具体操作放入文件或数据库中,传入id提取对应操作
            String operationId = request.getParameter("operationId");
            String operation = operationDao.selectByOperationId(operationId);
            engine.eval(request.getParameter(operation));
        } catch (ScriptException e) {
            //
        }
```
# Unreleased Resource:Files
## 漏洞代码

```java
@RequestMapping(value = "/urf", method = RequestMethod.GET)
    public void urf(HttpServletRequest request) throws IOException {
        ZipFile zipFile = null;
        String filePath = "";
        InputStream inputStream = null;
        try {
            zipFile = new ZipFile(filePath);
            Enumeration<? extends ZipEntry> entries = zipFile.entries();
            while (entries.hasMoreElements()) {
                ZipEntry zipEntry = entries.nextElement();
                String name = zipEntry.getName();
                inputStream = zipFile.getInputStream(zipEntry);
                //....
                if (inputStream != null) {
                    inputStream.close();
                }
            }
        }
        catch (Exception e){

        }
        finally {
            //该inputstream在上一步已经close 会抛出异常，导致下一步zipFile无法关闭。
            if(inputStream != null){
                inputStream.close();
            }
            if(zipFile != null) {
                zipFile.close();
            }
        }
    }

```
## 修复代码

```java
@RequestMapping(value = "/urf", method = RequestMethod.GET)
    public void urf(HttpServletRequest request) throws IOException {
        ZipFile zipFile = null;
        String filePath = "";
        InputStream inputStream = null;
        try {
            zipFile = new ZipFile(filePath);
            Enumeration<? extends ZipEntry> entries = zipFile.entries();
            while (entries.hasMoreElements()) {
                ZipEntry zipEntry = entries.nextElement();
                String name = zipEntry.getName();
                inputStream = zipFile.getInputStream(zipEntry);
                
            }
        }
        catch (Exception e){

        }
        finally {
            //流关闭操作统一在finally中处理
            if(inputStream != null){
                inputStream.close();
            }
            if(zipFile != null) {
                zipFile.close();
            }
        }
    }
```
# Weak Encryption:Byte Array toString Conversion
## 漏洞代码

```java
public String encrypContent(String content) throws Exception {
        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
        SecretKey secretKey = keyGenerator.generateKey();
        byte[] rawKey = secretKey.getEncoded();
        //使用默认的字符集将byte[]类型key转化为字符串,当key超出字符集的边界,很可能造成字节的丢失.
        String key = new String(rawKey);
        //...
    }
    ```

## 修复代码

```java
public String encrypContent(String content) throws Exception {
        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
        SecretKey secretKey = keyGenerator.generateKey();
        byte[] rawKey = secretKey.getEncoded();
        //使用base64的形式将byte转化为string,不会造成字节的丢失
        String key = Arrays.toString(Base64.getEncoder().encode(rawKey));
        //...
}

```